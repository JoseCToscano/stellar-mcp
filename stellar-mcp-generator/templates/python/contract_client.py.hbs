"""
Contract client for {{contract_name}}
Wraps stellar-contract-bindings generated code with MCP-friendly interface
"""

import re
from typing import Any, Dict, Optional, Union, List, TYPE_CHECKING
from dataclasses import dataclass

# Import the generated bindings from stellar-contract-bindings
try:
    from .bindings.bindings import ClientAsync as GeneratedClient
    # Import all types from bindings module to make them available for type hints
    from .bindings.bindings import *
except ImportError:
    raise ImportError(
        "Contract bindings not found. "
        "Please run: stellar-contract-bindings python --contract-id {{contract_id}} "
        "--rpc-url {{rpc_url}} --output ./src/bindings"
    )

@dataclass
class ContractConfig:
    """Configuration for the Soroban contract"""
    contract_id: str
    rpc_url: str
    network_passphrase: str


def convert_mcp_params(obj: Any) -> Any:
    """
    Helper to convert MCP tool parameters to Stellar SDK types:
    - None → None (Python handles Optional natively)
    - hex strings → bytes (for BytesN fields like 'salt', '*_hash', etc.)
    - numeric strings → int (for i128/u128 fields like '*_supply', 'cap', 'amount', etc.)

    This handles the same type conversions as the TypeScript generator's convertNullToUndefined.
    """
    if obj is None:
        return None

    if not isinstance(obj, (dict, list)):
        return obj

    if isinstance(obj, list):
        return [convert_mcp_params(item) for item in obj]

    result = {}
    for key, value in obj.items():
        # Convert hex strings to bytes for known Bytes fields
        if (isinstance(value, str) and
            (key == 'salt' or key.endswith('_hash') or key.endswith('_wasm')) and
            re.match(r'^[0-9a-fA-F]+$', value)):
            result[key] = bytes.fromhex(value)

        # Convert numeric strings to int for known i128/u128 fields
        elif (isinstance(value, str) and
              ('supply' in key or key in ('cap', 'amount', 'balance', 'value') or
               '_amount' in key or '_balance' in key) and
              re.match(r'^-?[0-9]+$', value)):
            result[key] = int(value)

        # Recursively convert nested objects
        elif isinstance(value, (dict, list)):
            result[key] = convert_mcp_params(value)

        else:
            result[key] = value

    return result


class ContractClient:
    """
    Wrapper around stellar-contract-bindings generated client
    Provides MCP-friendly interface for contract interactions
    """

    def __init__(self, config: ContractConfig):
        self.config = config
        # Initialize generated client from stellar-contract-bindings
        # The ClientAsync expects contract_id, rpc_url string, and network_passphrase
        self.client = GeneratedClient(
            contract_id=config.contract_id,
            rpc_url=config.rpc_url,
            network_passphrase=config.network_passphrase
        )

    {{#each functions}}
    async def {{name_snake}}(
        self,
        {{#each inputs}}
        {{name_snake}}: {{py_type}},
        {{/each}}
    ) -> Dict[str, Any]:
        """
        {{doc}}

        {{#if inputs}}
        Parameters:
        {{#each inputs}}
        - {{name_snake}} ({{py_type}}): {{#if doc}}{{doc}}{{else}}Contract parameter{{/if}}
        {{/each}}
        {{/if}}

        Returns:
            Dict with 'xdr' (transaction XDR) and 'simulationResult'
        """
        {{#if inputs}}
        # Convert MCP parameters to Stellar SDK types
        # This handles None, hex strings → bytes, numeric strings → int
        params = convert_mcp_params({
            {{#each inputs}}
            "{{name}}": {{name_snake}},
            {{/each}}
        })
        {{/if}}

        # Call the generated bindings method
        # The method returns an AssembledTransaction with .transaction and .simulation
        assembled = await self.client.{{name_snake}}({{#if inputs}}**params{{/if}})

        # Return transaction XDR and simulation result in MCP-compatible format
        return {
            "xdr": assembled.transaction.to_xdr(),
            "simulationResult": assembled.simulation if hasattr(assembled, 'simulation') else None
        }

    {{/each}}
